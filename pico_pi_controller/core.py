# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['goodbye', 'PPDeviceDaemon']

# Cell
from platform import node
from os import getloadavg
from sys import byteorder
import time
import pigpio
import atexit

@atexit.register
def goodbye():
    """Cancel pigpio event handler, close I2C peripheral & connection to pigpio"""
    try:
        e.cancel()
        pi.bsc_i2c(0) # Disable BSC peripheral
        pi.stop()
        print ("bsc_i2c cleanup completed.")
    except:
        print ("bsc_i2c error on cleanup.")
    print ('Exiting via atexit')

class PPDeviceDaemon():
    """Copied from local ppdd.py, soon to be made into a proper class."""
    def __init__(self):
        I2C_ADDR=0x13
        IDENTITY = bytearray('ppdd','utf-8')
        IDF = bytearray('I','utf-8')
        HOS = bytearray('H','utf-8')
        LOD = bytearray('L','utf-8')
        hostname = bytearray(node(),'utf-8')
        load = bytearray(str(getloadavg()[0]),'utf-8')

        pi = pigpio.pi()
        if not pi.connected:
            print ("pigpiod not running. Exiting.")
            exit()
        # setup event handler to listen for heartbeat from MCU
        e = pi.event_callback(pigpio.EVENT_BSC, self.i2c_event_handler)
        while True:
            #here goes the socket connection for ppcc & listening for system events
            time.sleep(600)

    def i2c_event_handler(id, tick):
        global pi

        s, b, d = pi.bsc_i2c(I2C_ADDR)
        if b:
            load = bytearray("{:04.2f}".format(getloadavg()[0]),'utf-8')
            if d[0] == int.from_bytes(IDF, byteorder=byteorder):
                print ("IDF recieved, sending identity:",IDENTITY.decode(),"on tick",tick)
                s, b, d = pi.bsc_i2c(I2C_ADDR,IDENTITY)
            elif d[0] == int.from_bytes(HOS, byteorder=byteorder):
                print ("HOS recieved, sending hostname:",hostname.decode())
                s, b, d = pi.bsc_i2c(I2C_ADDR, bytes([len(hostname)])+hostname)
            elif d[0] == int.from_bytes(LOD, byteorder=byteorder):
                print ("LOD recieved, sending load:",load.decode())
                s, b, d = pi.bsc_i2c(I2C_ADDR,load)
